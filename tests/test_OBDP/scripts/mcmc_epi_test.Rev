################################################################################
#
# RevBayes Validation Test: Fossilized birth-death process
#
# Model: Tree is drawn from a constant-rate fossilized birth-death process.
#
#
# authors: Walker Pett
#
################################################################################

seed(12345)

#######################
# Reading in the Data #
#######################

### Read in taxon data


# set my move index
mvi = 0
taxa <- readTaxonData("data-epi-test/data_taxa.csv")
sequences <- readDiscreteCharacterData("data-epi-test/data_seq.nex")
occurrence_ages <- readMatrix(file="data-epi-test/data_occurrences.csv", delimiter="; ")[1]

lambda ~ dnExp(10)
mu ~ dnExp(10)
psi ~ dnExp(10)
omega <- 0.0
rho <- 1.0
rm <- 0.0
N <- 30
cond <- "time"
start_time ~ dnUnif(7.7, 12.0)
useMt <- TRUE




 # create some moves that change the stochastic variables
 # all moves are sliding proposals but you could use scaling proposals for the rates too
moves[mvi++] = mvScale(lambda,lambda=1,weight=1)
moves[mvi++] = mvScale(lambda,lambda=0.1,weight=1)
moves[mvi++] = mvScale(lambda,lambda=0.01,weight=1)

moves[mvi++] = mvScale(mu,lambda=1,weight=1)
moves[mvi++] = mvScale(mu,lambda=0.1,weight=1)
moves[mvi++] = mvScale(mu,lambda=0.01,weight=1)

moves[mvi++] = mvScale(psi,lambda=1,weight=1)
moves[mvi++] = mvScale(psi,lambda=0.1,weight=1)
moves[mvi++] = mvScale(psi,lambda=0.01,weight=1)


### Define the tree-prior distribution as the fossilized birth-death process ###
obd_tree ~ dnOBDP(  originAge=start_time,
				    lambda=lambda,
				    mu=mu, 
				    psi=psi, 
				    omega=omega, 
				    rho=rho, 
				    removalPr=rm, 
				    maxHiddenLin=N, 
				    condition=cond, 
				    taxa=taxa, 
				    occurrence_ages=occurrence_ages, 
				    useMt=useMt)

moves[mvi++] = mvFNPR(obd_tree, weight=1.0)
moves[mvi++] = mvTipTimeSlideUniform(obd_tree, weight=1.0)
moves[mvi++] = mvNodeTimeSlideUniform(obd_tree, weight=1.0)
moves[mvi++] = mvRootTimeSlideUniform(obd_tree, start_time, weight=1.0)

branch_rates ~ dnExponential(250.0)

moves.append( mvScale(branch_rates, lambda=0.01, weight=4.0) )
moves.append( mvScale(branch_rates, lambda=0.1,  weight=4.0) )
moves.append( mvScale(branch_rates, lambda=1.0,  weight=4.0) )

pi_prior <- v(1,1,1,1)
pi ~ dnDirichlet(pi_prior)

moves.append( mvBetaSimplex(pi, weight=2) )
moves.append( mvDirichletSimplex(pi, weight=1) )

kappa ~ dnLognormal(0.0, 1.0)

moves.append( mvScale(kappa) )

Q_epi := fnHKY(kappa,pi)

alpha_epi ~ dnExponential( 1.0 )

moves.append( mvScale(alpha_epi, lambda=0.01, weight=1.0) )
moves.append( mvScale(alpha_epi, lambda=0.1,  weight=1.0) )
moves.append( mvScale(alpha_epi, lambda=1,    weight=1.0) )

rates_epi := fnDiscretizeGamma( alpha_epi, alpha_epi, 4 )


phySeq ~ dnPhyloCTMC(tree=obd_tree, Q=Q_epi, siteRates=rates_epi, branchRates=branch_rates, type="DNA")
phySeq.clamp(sequences)


#############
# THE Model #
#############

# We define our model.
# We can use any node of our model as a handle, here we chose to use the rate matrix.
mymodel = model(obd_tree)


monitors[1] = mnStochasticVariable(filename="output/mcmc_OBDP_wo_oc_epi.out", printgen=100)
monitors[2] = mnFile(filename="output/mcmc_OBDP_epi.trees", printgen=100,obd_tree)
print("my model ok")
mymcmc = mcmc(mymodel, monitors, moves, moveschedule="single")


mymcmc.run(generations=1000)


# Read in the tree trace and construct the maximum clade credibility (MCC) tree #
trace = readTreeTrace("output/mcmc_OBDP_wo_oc_epi.trees")

# Summarize tree trace and save MCC tree to file
mccTree(trace, file="output/mcmc_OBDP_wo_oc_epi.tre" )


# you may want to quit RevBayes now
q()
